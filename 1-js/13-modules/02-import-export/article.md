# Export e Import

As diretivas export e import t√™m diversas variantes de sintaxe.

No artigo anterior vimos um uso simples, agora vamos explorar mais exemplos.

## Export before declarations

Podemos rotular qualquer declara√ß√£o como exportada colocando `export` antes dela, seja uma vari√°vel, fun√ß√£o ou classe.

Por exemplo, todas essas express√µes s√£o v√°lidas:

```js
// exportando um array
*!*export*/!* let months = ['Jan', 'Fev', 'Mar','Abr', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];

// exportando uma constante
*!*export*/!* const MODULES_BECAME_STANDARD_YEAR = 2015;

// exportando uma classe
*!*export*/!* class User {
  constructor(name) {
    this.name = name;
  }
}
```

````smart header="Sem ponto e v√≠rgula depois de export class/function"
Note que `export` antes de uma classe ou uma fun√ß√£o n√£o a torna uma [function expression](info:function-expressions-arrows). Ainda √© uma declara√ß√£o de fun√ß√£o, embora exportada.

A maioria dos guias de estilo n√£o recomendam ponto e v√≠rgula depois da declara√ß√£o de fun√ß√µes ou de classes.

√â por isso que n√£o h√° necessidade para ponto e v√≠rgula no fim de `export class` e `export function`:

```js
export function sayHi(user) {
  alert(`Ol√°, ${user}!`);
} *!* // sem ; no final */!*
```

````

## Export separado das declara√ß√µes

Al√©m disso, podemos colocar `export` separadamente.

Aqui primeiro declaramos e ent√£o exportamos:

```js  
// üìÅ say.js
function sayHi(user) {
  alert(`Ol√°, ${user}!`);
}

function sayBye(user) {
  alert(`Tchau, ${user}!`);
}

*!*
export {sayHi, sayBye}; // uma lista de vari√°veis exportadas
*/!*
```

...Ou tecnicamente podemos colocar `export` acima das fun√ß√µes tamb√©m.

## Import *

Normalmente, colocamos uma lista do que importar entre chaves `import {...}`, assim:

```js
// üìÅ main.js
*!*
import {sayHi, sayBye} from './say.js';
*/!*

sayHi('John'); // Ol√°, John!
sayBye('John'); // Tchau, John!
```

Mas se houver muita coisa para importar, podemos importar tudo como um objeto usando `import * as <obj>`, por exemplo:

```js
// üìÅ main.js
*!*
import * as say from './say.js';
*/!*

say.sayHi('John');
say.sayBye('John');
```

√Ä primeira vista, "importar tudo" parece algo muito legal, curto para escrever, ent√£o por que devemos listar explicitamente o que precisamos importar?

Bem, existem algumas raz√µes.

1. Ferramentas modernas de build ([webpack](http://webpack.github.io) e outras) agrupam os m√≥dulos e os otimizam para acelerar o carregamento e remover itens n√£o utilizados.

    Digamos que adicionamos a biblioteca externa `say.js` em nosso projeto com muitas fun√ß√µes:
    ```js
    // üìÅ say.js
    export function sayHi() { ... }
    export function sayBye() { ... }
    export function becomeSilent() { ... }
    ```

    Agora, se precisarmos apenas de uma das fun√ß√µes de `say.js` em nosso projeto:
    ```js
    // üìÅ main.js
    import {sayHi} from './say.js';
    ```
    ...Ent√£o o otimizador vai ver isso e remover as outras fun√ß√µes n√£o utilizadas no c√≥digo agrupado, tornando o build menor. Isso √© chamado de "tree-shaking".

2. Listar explicitamente o que importar nos fornece nomes mais curtos: `sayHi()` ao inv√©s de `say.sayHi()`.
3. Uma lista expl√≠cita do que importar fornece uma vis√£o geral melhor da estrutura do c√≥digo: o que √© usado e onde. Torna o c√≥digo f√°cil de prover suporte e de refatorar.

## Import "as"

Tamb√©m podemos usar `as` para importar com diferentes nomes.

Por exemplo, vamos importar `sayHi` na vari√°vel local `hi` por quest√µes de brevidade e importar `sayBye` como `bye`:

```js
// üìÅ main.js
*!*
import {sayHi as hi, sayBye as bye} from './say.js';
*/!*

hi('John'); // Ol√°, John!
bye('John'); // Tchau, John!
```

## Export "as"

Uma sintaxe similar existe para `export`.

Vamos exportar fun√ß√µes como `hi` e `bye`:

```js
// üìÅ say.js
...
export {sayHi as hi, sayBye as bye};
```

Agora `hi` e `bye` s√£o nomes oficias para quem v√™ de fora, para serem usadas nos imports:

```js
// üìÅ main.js
import * as say from './say.js';

say.*!*hi*/!*('John'); // Ol√°, John!
say.*!*bye*/!*('John'); // Tchau, John!
```

## Export default

Na pr√°tica, exitem principalmente dois tipos de m√≥dulos.

1. M√≥dulos que cont√©m uma biblioteca, pacote de fun√ß√µes, como `say.js` acima.
2. M√≥dulos que declaram uma √∫nica entidade, por exemplo um m√≥dulo `user.js` exportando apenas `class User`.

Na maioria dos casos, a segunda abordagem √© preferida, para que cada "coisa" tenha seu pr√≥prio m√≥dulo.

Naturalmente isso exige muitos arquivos porque tudo precisa do seu pr√≥prio m√≥dulo, mas isso n√£o √© problema. Na verdade a navega√ß√£o do c√≥digo se torna mais f√°cil se os arquivos forem bem nomeados e estruturados em pastas.

M√≥dulos fornecem a sintaxe especial `export default` ("a exporta√ß√£o default") para melhorar a apar√™ncia de "uma coisa por m√≥dulo".

Coloque `export default` antes da entidade a ser exportada:

```js
// üìÅ user.js
export *!*default*/!* class User { // apenas adicione "default"
  constructor(name) {
    this.name = name;
  }
}
```

Pode existir apenas um `export default` por arquivo.

...E ent√£o importamos sem as chaves:

```js
// üìÅ main.js
import *!*User*/!* from './user.js'; // n√£o {User}, apenas User

new User('John');
```

Imports sem chaves parecem mais agrad√°veis. Um erro comum quando se come√ßa a usar m√≥dulos √© esquecer das chaves. Ent√£o, lembre-se, `import` precisa de chaves para imports nomeados (named imports) e n√£o precisa para os imports default.

| Export nomeado | Export default |
|--------------|----------------|
| `export class User {...}` | `export default class User {...}` |
| `import {User} from ...` | `import User from ...`|

Tecnicamente, podemos ter tanto exports nomeados como exports default em um √∫nico m√≥dulo, mas na pr√°tica as pessoas geralmente n√£o misturam os dois. Um m√≥dulo possui exports nomeados ou o export default.

Como pode haver no m√°ximo um export default por arquivo, a entidade exportada pode n√£o ter nome.

Por exemplo, todos esses exports default s√£o perfeitamente v√°lidos:

```js
export default class { // classe sem nome
  constructor() { ... }
}
```

```js
export default function(user) { // fun√ß√£o sem nome
  alert(`Ol√°, ${user}!`);
}
```

```js
// exporta um √∫nico valor, sem criar uma vari√°vel
export default ['Jan', 'Fev', 'Mar','Abr', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
```

N√£o prover um nome √© ok, porque deve ter apenas um `export default` por arquivo, ent√£o `import` sem as chaves vai saber o que importar.

Sem `default`, esse export causaria um erro:

```js
export class { // Erro! (exports que n√£o s√£o default precisam de um nome)
  constructor() {}
}
```     

### O nome "default"

Em algumas situa√ß√µes a palavra-chave `default` √© usada para referenciar o export default.

Por exemplo, para exportar uma fun√ß√£o separadamente da sua defini√ß√£o:

```js
function sayHi(user) {
  alert(`Ol√°, ${user}!`);
}

//  o mesmo que adicionar "export default" antes da fun√ß√£o
export {sayHi as default};
```

Ou, em outra situa√ß√£o, digamos que um m√≥dulo `user.js` tenha um export principal "default" e alguns outros nomeados (caso raro, mas acontece):

```js
// üìÅ user.js
export default class User {
  constructor(name) {
    this.name = name;
  }
}

export function sayHi(user) {
  alert(`Ol√°, ${user}!`);
}
```

Assim √© como importamos o export default junto com um nomeado:

```js
// üìÅ main.js
import {*!*default as User*/!*, sayHi} from './user.js';

new User('John');
```

E, finalmente, se importarmos tudo `*` como um objeto, ent√£o a propriedade `default` √© exatamente o export default:

```js
// üìÅ main.js
import * as user from './user.js';

let User = user.default; // o export default
new User('John');
```

### Uma palavra contra exports default

Exports nomeados s√£o expl√≠citos. Eles nomeiam exatamente o que importam, ent√£o temos essas informa√ß√µes e isso √© uma coisa boa.

Exports nomeados nos for√ßam a usar exatamente o nome certo para importar:

```js
import {User} from './user.js';
// import {MyUser} n√£o funciona, o nome deve ser {User}
```

...Enquanto para o export default, n√≥s sempre escolhemos o nome ao importar:

```js
import User from './user.js'; // funciona
import MyUser from './user.js'; // Tamb√©m funciona
// pode ser import QualquerCoisa..., e ainda vai funcionar
```

Membros da mesma equipe podem usar nomes diferentes para importar a mesma coisa, e isso n√£o √© bom.

Geralmente, para evitar isso e manter o c√≥digo consistente, existe uma regra que as vari√°veis importadas devem corresponder ao nome dos arquivos, por exemplo:

```js
import User from './user.js';
import LoginForm from './loginForm.js';
import func from '/path/to/func.js';
...
```

Ainda assim, algumas equipes consideram isso uma s√©ria desvantagem dos exports default. Ent√£o, eles preferem usar sempre exports com nomes. Mesmo se apenas uma coisa √© exportada, ela ainda ser√° exportada com um nome, sem `default`.

Isso tamb√©m facilita a a reexporta√ß√£o (veja abaixo).

## Reexporta√ß√£o

A sintaxe de reexporta√ß√£o `export ... from ...` permite importar coisas e imediatamente export√°-las (possivelmente com outro nome), assim:

```js
export {sayHi} from './say.js'; // reexporta sayHi

export {default as User} from './user.js'; // reexporta o default
```

Por que isso seria necess√°rio? Vamos ver um caso de uso pr√°tico.

Imagine, we're writing a "package": a folder with a lot of modules, with some of the functionality exported outside (tools like NPM allow us to publish and distribute such packages, but we don't have to use them), and many modules are just "helpers", for internal use in other package modules.

A estrutura de arquivos pode ser assim:
```
auth/
    index.js  
    user.js
    helpers.js
    tests/
        login.js
    providers/
        github.js
        facebook.js
        ...
```

Gostar√≠amos de exportar a funcionalidade do pacote via um √∫nico ponto de entrada.

Por outras palavras, uma pessoa que quisesse usar o nosso pacote, deveria importar o arquivo principal `auth/index.js`.

Desta forma:

```js
import {login, logout} from 'auth/index.js'
```

O "arquivo principal" `auth/index.js`, exporta todas as funcionalidades que gostar√≠amos de fornecer no nosso pacote.

A ideia √© que os desenvolvedores que utilizarem nosso pacote n√£o possam interferir na sua estrutura interna. Eles n√£o devem procurar por arquivos dentro da pasta do nosso pacote. Apenas exportamos o que for necess√°rio no `auth/index.js` e mantemos o resto escondido de olhos curiosos.

Como as funcionalidade exportadas est√£o espalhadas pelo pacote, podemos import√°-las em `auth / index.js` e export√°-las nele:

```js
// üìÅ auth/index.js

// import login/logout e imediatamente export√°-los
import {login, logout} from './helpers.js';
export {login, logout};

// importar default como User e export√°-lo
import User from './user.js';
export {User};
...
```

Agora os usu√°rios do nosso pacote podem  `import {login} from "auth/index.js"`.

A sintaxe `export ... from ...` √© apenas uma nota√ß√£o mais curta para essa import-export:

```js
// üìÅ auth/index.js
// re-exportar login/logout
export {login, logout} from './helpers.js';

// re-exportar o 'export default' como User
export {default as User} from './user.js';
...
```

Uma diferen√ßa not√°vel entre `export ... from` e `import/export` est√° em que m√≥dulos re-exportados n√£o est√£o dispon√≠veis no arquivo corrente. Assim, dentro do exemplo acima de `auth/index.js` n√≥s n√£o podemos utilizar fun√ß√µes `login/logout` re-exportadas.

### Reexportando o export default

O export default precisa de um tratamento separado ao reexportar.

Digamos que n√≥s temos `user.js` com o `export default class User` e gostar√≠amos de o re-exportar:

```js
// üìÅ user.js
export default class User {
  // ...
}
```   

Podemos nos deparar com dois problemas para isso:

1. `export User from './user.js'` n√£o funcionar√°. Isso levaria a um erro de sintaxe.

    Para reexportar o export default, n√≥s temos que escrever `export {default as User}`, como no exemplo acima.

2. `export * from './user.js'` reexporta apenas os exports com nome, mas ignora o default.

    Se desejarmos reexportar tanto os export com nome e o export default, ser√£o necess√°rias duas declara√ß√µes:
    ```js
    export * from './user.js'; // para reexportar exports com nome
    export {default} from './user.js'; // para reexportar o export default
    ```

Essas esquisitices de reexportar um default export s√£o um dos motivos pelos quais alguns desenvolvedores n√£o gostam de default exports e preferem os nomeados.

## Resumo

Aqui est√£o todos os tipos de `export` que abordamos neste e em artigos anteriores.

Voc√™ pode verificar lendo-os e relembrando o que eles significam:

- Antes da declara√ß√£o de uma class/function/..:
  - `export [default] class/function/variable ...`
- Standalone:
  - `export {x [as y], ...}`.
- Reexporta√ß√£o:
  - `export {x [as y], ...} from "module"`
  - `export * from "module"` (n√£o reexporta o default).
  - `export {default [as y]} from "module"` (reexporta o default).

Import:

- Importando exports com nome:
  - `import {x [as y], ...} from "module"`
- Importando o export default:  
  - `import x from "module"`
  - `import {default as x} from "module"`
- Importar tudo:
  - `import * as obj from "module"`
- Importar o m√≥dulo (o seu c√≥digo √© executado), sem atribuir nenhum dos seus exports a vari√°veis:
  - `import "module"`

Podemos colocar as declara√ß√µes `import/export` no in√≠cio ou no final de um script, isso n√£o importa.

Ent√£o, tecnicamente, esse c√≥digo √© correto:
```js
sayHi();

// ...

import {sayHi} from './say.js'; // import no final do arquivo
```

Na pr√°tica, as importa√ß√µes normalmente ficam no in√≠cio do arquivo, mas isso √© apenas por conveni√™ncia.

**Observe que as declara√ß√µes de importa√ß√£o e exporta√ß√£o n√£o funcionam dentro de `{...}`.**

Um import condicional como esse n√£o vai funcionar:
```js
if (something) {
  import {sayHi} from "./say.js"; // Erro: importa√ß√£o deve estar em um n√≠vel acima
}
```

... Mas e se realmente precisarmos importar algo condicionalmente? Ou na hora certa? Como, carregar um m√≥dulo mediante solicita√ß√£o, quando √© realmente necess√°rio?

Veremos importa√ß√µes din√¢micas no pr√≥ximo artigo.
